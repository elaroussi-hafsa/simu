import math
import numpy as np

class DoublePendulum:

    def __init__(self, length1, length2, angle1, angle2, p1, p2, gravity, m1, m2, dt):
        self.origin = (0, 0)
        self.angle1 = math.radians(angle1)
        self.angle2 = math.radians(angle2)
        self.p1 = p1
        self.p2 = p2
        self.length1 = length1
        self.length2 = length2
        self.gravity = gravity
        self.m1 = m1
        self.m2 = m2
        self.dt = dt
        self.position1 = (self.origin[0] + self.length1 * math.sin(self.angle1), self.origin[1] - self.length1 * math.cos(self.angle1))
        self.position2 = (self.position1[0] + self.length2 * math.sin(self.angle2), self.position1[1] - self.length2 * math.cos(self.angle2))

    def compute_positions(self):
       # Calculate the new positions of the pendulum arms and bobs
        # based on the current positions, velocities, and gravity
        current_state = [self.angle1, self.p1, self.angle2, self.p2]
        #F_A is just here to make the code simpler using those variables
        F_A = lambda y1: [(y1[1] * y1[3] * math.sin(y1[0] - y1[2])) / (self.length1 * self.length2 * (self.m1 + self.m2 * math.sin(y1[0] - y1[2])**2)),
                (1 / (2 * self.length1**2 * self.length2**2 * (self.m1 + self.m2 * math.sin(y1[0] - y1[2])**2)**2)) * ((y1[1]**2 * self.m2 * self.length2**2) - (2 * y1[1] * y1[3] * self.m2 * self.length1 * self.length2 * math.cos(y1[0] - y1[2])) + (y1[3]**2 * (self.m1 + self.m2) * self.length1**2)) * math.sin(2 * (y1[0] - y1[2]))]

        
        F = lambda y2: [(y2[1] * self.length2 - y2[3] * self.length1 * math.cos(y2[0] - y2[2])) / (self.length1**2 * self.length2 * (self.m1 + self.m2 * math.sin(y2[0] - y2[2])**2)),
                -((self.m1 + self.m2) * self.gravity * self.length1 * math.sin(y2[0])) - A_1 + A_2,
                (y2[3] * (self.m1 + self.m2) * self.length1 - y2[1] * self.m2 * self.length2 * math.cos(y2[0] - y2[2])) / (self.m2 * self.length1 * self.length2**2 * (self.m1 + self.m2 * math.sin(y2[0] - y2[2])**2)),
                -(self.m2 * self.gravity * self.length2 * math.sin(y2[2])) + A_1 - A_2]
        
        
        A_1,A_2=F_A(current_state)        
        Y1 = [self.dt * x for x in F(current_state)]
        A_1,A_2=F_A(np.array(current_state)+np.array([0.5 * f_i for f_i in Y1]))
        Y2=[self.dt * x for x in F(np.array(current_state)+np.array([0.5 * f_i for f_i in Y1]))]
        A_1,A_2=F_A(np.array(current_state)+np.array([0.5 * f_i for f_i in Y2]))
        Y3=[self.dt * x for x in F(np.array(current_state)+np.array([0.5 * f_i for f_i in Y2]))]
        A_1,A_2=F_A(np.array(current_state)+np.array(Y3))
        Y4=[self.dt * x for x in F(np.array(current_state)+(Y3))]
        Y=(np.array(Y1)+np.array([2 * x for x in Y2])+np.array([2 * x for x in Y3])+np.array(Y4))
        [self.angle1, self.p1, self.angle2, self.p2] = np.array(current_state) + np.array([(1/6) * x for x in Y])
        
        self.position1 = (self.origin[0] + self.length1 * math.sin(self.angle1), self.origin[1] - self.length1 * math.cos(self.angle1))
        self.position2 = (self.position1[0] + self.length2 * math.sin(self.angle2),self.position1[1] - self.length2 * math.cos(self.angle2))


 
    def spin_up(self, duration):
        # Choose an arbitrary initial condition with small amplitude
        #  randomly choose small values for the angles and momenta
        initial_angles = np.random.uniform(-0.01, 0.01, size=2)
        initial_momenta = np.random.uniform(-0.01, 0.01, size=2)

        # Integrate the tangent linear evolution for the given duration
        current_state = np.concatenate((initial_angles, initial_momenta))
        tangent_vector = np.zeros_like(current_state)
        tangent_vector[:2] = np.random.normal(size=2)
        tangent_vector[:2] /= np.linalg.norm(tangent_vector[:2])

        for _ in range(int(duration / self.dt)):
            A_1, A_2 = self._compute_F_A(current_state)
            Y1 = [self.dt * x for x in self._compute_F(current_state)]
            A_1, A_2 = self._compute_F_A(current_state + 0.5 * np.array(Y1))
            Y2 = [self.dt * x for x in self._compute_F(current_state + 0.5 * np.array(Y1))]
            A_1, A_2 = self._compute_F_A(current_state + 0.5 * np.array(Y2))
            Y3 = [self.dt * x for x in self._compute_F(current_state + 0.5 * np.array(Y2))]
            A_1, A_2 = self._compute_F_A(current_state + np.array(Y3))
            Y4 = [self.dt * x for x in self._compute_F(current_state + np.array(Y3))]
            Y = np.array(Y1) + 2 * np.array(Y2) + 2 * np.array(Y3) + np.array(Y4)
            current_state += Y / 6
            tangent_state = np.concatenate((tangent_vector[:2], np.zeros(2), tangent_vector[2:]))
            tangent_Y = np.array([
                [0, 1, 0, 0],
                [0, 0, A_1, A_2],
                [0, 0, 0, 1],
                [0, 0, A_2, A_1],
            ]) @ tangent_state
            tangent_Y /= np.linalg.norm(tangent_Y[:2])
            tangent_vector += tangent_Y * self.dt

        # Renormalize the tangent vector to obtain a unit vector in the unstable direction
        self.unstable_direction = tangent_vector[:2] / np.linalg.norm(tangent_vector[:2])

  
    def Cmputation_lyapunov_exponent(self):        
        
                
       # Create a DoublePendulum instance
       pendulum = DoublePendulum(length1=1, length2=1, angle1=0, angle2=0, p1=0, p2=0, gravity=9.81, m1=1, m2=1, dt=0.01)

       # Call the spin_up method for 10 seconds
       pendulum.spin_up(duration=10)

       # Get the final angles and momenta
       final_angles = np.array([pendulum.angle1, pendulum.angle2])
       final_momenta = np.array([pendulum.p1, pendulum.p2])

       # Generate a new set of initial conditions with small perturbations 
       new_angles = np.random.uniform(final_angles - 0.01, final_angles + 0.01)
       new_momenta = np.random.uniform(final_momenta - 0.01, final_momenta + 0.01)

      
       new_initial_conditions=[new_angles[0], new_angles[1], new_momenta[0], new_momenta[1]]  
       
