analytical_solution[i] = (
        (c1 / 2)
        * np.power(np.cosh(math.sqrt(c1) / 2 * (x - a1 * L - i * dt)), -2)
        + (c2 / 2)
        * np.power(np.cosh(math.sqrt(c2) / 2 * (x - a2 * L - i * dt)), -2)
    )
19:44
Vous avez envoyÃ©
import math
import numpy as np

class DoublePendulum:

    def __init__(self, length1, length2, angle1, angle2, p1, p2, gravity, m1, m2, dt):
        self.origin = (0, 0)
        self.angle1 = math.radians(angle1)
        self.angle2 = math.radians(angle2)
        self.p1 = p1
        self.p2 = p2
        self.length1 = length1
        self.length2 = length2
        self.gravity = gravity
        self.m1 = m1
        self.m2 = m2
        self.dt = dt
        self.position1 = (self.origin[0] + self.length1 * math.sin(self.angle1), self.origin[1] - self.length1 * math.cos(self.angle1))
        self.position2 = (self.position1[0] + self.length2 * math.sin(self.angle2), self.position1[1] - self.length2 * math.cos(self.angle2))

    def compute_positions(self):
       # Calculate the new positions of the pendulum arms and bobs
        # based on the current positions, velocities, and gravity
        current_state = [self.angle1, self.p1, self.angle2, self.p2]
        #F_A is just here to make the code simpler using those variables
        F_A = lambda y1: [(y1[1] * y1[3] * math.sin(y1[0] - y1[2])) / (self.length1 * self.length2 * (self.m1 + self.m2 * math.sin(y1[0] - y1[2])**2)),
                (1 / (2 * self.length1**2 * self.length2**2 * (self.m1 + self.m2 * math.sin(y1[0] - y1[2])**2)**2)) * ((y1[1]**2 * self.m2 * self.length2**2) - (2 * y1[1] * y1[3] * self.m2 * self.length1 * self.length2 * math.cos(y1[0] - y1[2])) + (y1[3]**2 * (self.m1 + self.m2) * self.length1**2)) * math.sin(2 * (y1[0] - y1[2]))]

        
        F = lambda y2: [(y2[1] * self.length2 - y2[3] * self.length1 * math.cos(y2[0] - y2[2])) / (self.length1**2 * self.length2 * (self.m1 + self.m2 * math.sin(y2[0] - y2[2])**2)),
                -((self.m1 + self.m2) * self.gravity * self.length1 * math.sin(y2[0])) - A_1 + A_2,
                (y2[3] * (self.m1 + self.m2) * self.length1 - y2[1] * self.m2 * self.length2 * math.cos(y2[0] - y2[2])) / (self.m2 * self.length1 * self.length2**2 * (self.m1 + self.m2 * math.sin(y2[0] - y2[2])**2)),
                -(self.m2 * self.gravity * self.length2 * math.sin(y2[2])) + A_1 - A_2]
        
        
        A_1,A_2=F_A(current_state)        
        Y1 = [self.dt * x for x in F(current_state)]
        A_1,A_2=F_A(np.array(current_state)+np.array([0.5 * f_i for f_i in Y1]))
        Y2=[self.dt * x for x in F(np.array(current_state)+np.array([0.5 * f_i for f_i in Y1]))]
        A_1,A_2=F_A(np.array(current_state)+np.array([0.5 * f_i for f_i in Y2]))
        Y3=[self.dt * x for x in F(np.array(current_state)+np.array([0.5 * f_i for f_i in Y2]))]
        A_1,A_2=F_A(np.array(current_state)+np.array(Y3))
        Y4=[self.dt * x for x in F(np.array(current_state)+(Y3))]
        Y=(np.array(Y1)+np.array([2 * x for x in Y2])+np.array([2 * x for x in Y3])+np.array(Y4))
        [self.angle1, self.p1, self.angle2, self.p2] = np.array(current_state) + np.array([(1/6) * x for x in Y])
        
        self.position1 = (self.origin[0] + self.length1 * math.sin(self.angle1), self.origin[1] - self.length1 * math.cos(self.angle1))
        self.position2 = (self.position1[0] + self.length2 * math.sin(self.angle2),self.position1[1] - self.length2 * math.cos(self.angle2))


 
    def spin_up(self, duration):
        # Choose an arbitrary initial condition with small amplitude
        #  randomly choose small values for the angles and momenta
        initial_angles = np.random.uniform(-0.01, 0.01, size=2)
        initial_momenta = np.random.uniform(-0.01, 0.01, size=2)

        # Integrate the tangent linear evolution for the given duration
        current_state = np.concatenate((initial_angles, initial_momenta))
        tangent_vector = np.zeros_like(current_state)
        tangent_vector[:2] = np.random.normal(size=2)
        tangent_vector[:2] /= np.linalg.norm(tangent_vector[:2])

        for _ in range(int(duration / self.dt)):
            current_state = [self.angle1, self.p1, self.angle2, self.p2]
            #F_A is just here to make the code simpler using those variables
            F_A = lambda y1: [(y1[1] * y1[3] * math.sin(y1[0] - y1[2])) / (self.length1 * self.length2 * (self.m1 + self.m2 * math.sin(y1[0] - y1[2])**2)),
                (1 / (2 * self.length1**2 * self.length2**2 * (self.m1 + self.m2 * math.sin(y1[0] - y1[2])**2)**2)) * ((y1[1]**2 * self.m2 * self.length2**2) - (2 * y1[1] * y1[3] * self.m2 * self.length1 * self.length2 * math.cos(y1[0] - y1[2])) + (y1[3]**2 * (self.m1 + self.m2) * self.length1**2)) * math.sin(2 * (y1[0] - y1[2]))]

        
            F = lambda y2: [(y2[1] * self.length2 - y2[3] * self.length1 * math.cos(y2[0] - y2[2])) / (self.length1**2 * self.length2 * (self.m1 + self.m2 * math.sin(y2[0] - y2[2])**2)),
                -((self.m1 + self.m2) * self.gravity * self.length1 * math.sin(y2[0])) - A_1 + A_2,
                (y2[3] * (self.m1 + self.m2) * self.length1 - y2[1] * self.m2 * self.length2 * math.cos(y2[0] - y2[2])) / (self.m2 * self.length1 * self.length2**2 * (self.m1 + self.m2 * math.sin(y2[0] - y2[2])**2)),
                -(self.m2 * self.gravity * self.length2 * math.sin(y2[2])) + A_1 - A_2]
            A_1, A_2 = F_A(current_state)
            Y1 = [self.dt * x for x in F(current_state)]
            A_1, A_2 = self.F_A(current_state + 0.5 * np.array(Y1))
            Y2 = [self.dt * x for x in F(current_state + 0.5 * np.array(Y1))]
            A_1, A_2 = self.F_A(current_state + 0.5 * np.array(Y2))
            Y3 = [self.dt * x for x in self.F(current_state + 0.5 * np.array(Y2))]
            A_1, A_2 = self.F_A(current_state + np.array(Y3))
            Y4 = [self.dt * x for x in self.F(current_state + np.array(Y3))]
            Y = np.array(Y1) + 2 * np.array(Y2) + 2 * np.array(Y3) + np.array(Y4)
            current_state += Y / 6
            tangent_state = np.concatenate((tangent_vector[:2], np.zeros(2), tangent_vector[2:]))
            tangent_Y = np.array([
                [0, 1, 0, 0],
                [0, 0, A_1, A_2],
                [0, 0, 0, 1],
                [0, 0, A_2, A_1],
            ]) @ tangent_state
            tangent_Y /= np.linalg.norm(tangent_Y[:2])
            tangent_vector += tangent_Y * self.dt

        # Renormalize the tangent vector to obtain a unit vector in the unstable direction
        self.unstable_direction = tangent_vector[:2] / np.linalg.norm(tangent_vector[:2])

  
    def Computation_lyapunov_exponent(self):        
        
                
       # Create a DoublePendulum instance
       pendulum = DoublePendulum(length1=1, length2=1, angle1=0, angle2=0, p1=0, p2=0, gravity=9.81, m1=1, m2=1, dt=0.01)

       # Call the spin_up method for 10 seconds
       pendulum.spin_up(duration=10)

       # Get the final angles and momenta
       final_angles = np.array([pendulum.angle1, pendulum.angle2])
       final_momenta = np.array([pendulum.p1, pendulum.p2])

      # Generate a new set of initial conditions with small perturbations
       num_trials = 100  # Number of trials to average the Lyapunov exponent
       max_iterations = 1000  # Maximum number of iterations to converge
       convergence_threshold = 0.00001 # Threshold to check convergence
       sum_log_diff = 0  # Sum of logarithmic differences
       prev_max_lambda = -100000000  # Previous maximum Lyapunov exponent

       for trial in range(num_trials):
        # Generate new initial conditions with perturbations
         new_angles = np.random.uniform(final_angles - 0.01, final_angles + 0.01)
         new_momenta = np.random.uniform(final_momenta - 0.01, final_momenta + 0.01)
         new_initial_conditions = [new_angles[0], new_angles[1], new_momenta[0], new_momenta[1]]

         # Integrate tangent linear evolution until convergence
         for iteration in range(max_iterations):
            # Create a new instance with perturbed initial conditions
            perturbed_pendulum = DoublePendulum(length1=1, length2=1, angle1=new_initial_conditions[0],
                                                angle2=new_initial_conditions[1], p1=new_initial_conditions[2],
                                                p2=new_initial_conditions[3], gravity=9.81, m1=1, m2=1, dt=0.01)

            # Spin up the perturbed pendulum for a duration
            perturbed_pendulum.spin_up(duration=10)

            # Get the final angles and momenta of the perturbed pendulum
            perturbed_final_angles = np.array([perturbed_pendulum.angle1, perturbed_pendulum.angle2])
            perturbed_final_momenta = np.array([perturbed_pendulum.p1, perturbed_pendulum.p2])

            # Calculate the logarithmic difference between perturbed and unperturbed final conditions
            log_diff = np.log(np.abs(perturbed_final_angles - final_angles) +
                             np.abs(perturbed_final_momenta - final_momenta))

            # Add the logarithmic difference to the sum
            sum_log_diff += log_diff

            # Calculate the average logarithmic difference
            avg_log_diff = sum_log_diff / (iteration + 1)

            # Calculate the maximum Lyapunov exponent
            max_lambda = avg_log_diff / (100 * pendulum.dt)

            # Check for convergence
            if iteration > 0 and np.abs(max_lambda - prev_max_lambda) < convergence_threshold:
                print(f"Converged after {iteration} iterations")
                break

            # Update the previous maximum Lyapunov exponent
            prev_max_lambda = max_lambda


    # Return the new initial conditions for further analysis
       return new_initial_conditions
   
    
    def Identify_chaotic_threshold():
           # Create a DoublePendulum instance
           pendulum = DoublePendulum(length1=1, length2=1, angle1=0, angle2=0, p1=0, p2=0, gravity=9.81, m1=1, m2=1, dt=0.01)

           # Call the spin_up method for 10 seconds
           pendulum.spin_up(duration=10)
         

           # Get the final angles and momenta
           final_angles = np.array([pendulum.angle1, pendulum.angle2])
           final_momenta = np.array([pendulum.p1, pendulum.p2])

           # Set the energy range and step size
           energy_range = np.arange(0.1, 5, 0.1)

           # Iterate over different energy levels
           for energy in energy_range:
             # Generate new initial conditions with the specified energy level
             new_angles = np.random.uniform(final_angles - energy, final_angles + energy)
             new_momenta = np.random.uniform(final_momenta - energy, final_momenta + energy)
             new_initial_conditions = [new_angles[0], new_angles[1], new_momenta[0], new_momenta[1]]

             # Integrate tangent linear evolution
             max_lambda_list = []
             for i in range(1000):  # Perform 1000 iterations to ensure convergence
               # Create a new instance with perturbed initial conditions
               perturbed_pendulum = DoublePendulum(length1=1, length2=1, angle1=new_initial_conditions[0],
                                                angle2=new_initial_conditions[1], p1=new_initial_conditions[2],
                                                p2=new_initial_conditions[3], gravity=9.81, m1=1, m2=1, dt=0.01)

               # Spin up the perturbed pendulum for a duration
               perturbed_pendulum.spin_up(duration=10)

               # Calculate the maximum Lyapunov exponent
               max_lambda = np.max(perturbed_pendulum.lambda_max)

               # Add the maximum Lyapunov exponent to the list
               max_lambda_list.append(max_lambda)

               # Check the sign of the maximum Lyapunov exponent
               if np.mean(max_lambda_list) > 0:
                 print(f"Energy threshold for chaos: {energy}")
                 return
